var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"Pressure_Analog_PWM","ref":false,"files":[{"name":"Pressure_Analog_PWM.c","type":"source","group":"model","path":"C:\\Users\\kamil\\OneDrive\\Documents\\GitHub\\NXP_Tests_Scaleo\\Pressure_Analog_PWM_mbd_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: Pressure_Analog_PWM.c\r\n *\r\n * Code generated for Simulink model 'Pressure_Analog_PWM'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Wed Mar 22 12:29:08 2023\r\n *\r\n * Target selection: mbd_s32k.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"Pressure_Analog_PWM.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"Pressure_Analog_PWM_private.h\"\r\n\r\n/* Exported block states */\r\nuint32_T analog_read;                  /* '<Root>/Data Store Memory' */\r\n\r\n/* Block signals (default storage) */\r\nB_Pressure_Analog_PWM_T Pressure_Analog_PWM_B;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_Pressure_Analog_PWM_T Pressure_Analog_PWM_M_;\r\nRT_MODEL_Pressure_Analog_PWM_T *const Pressure_Analog_PWM_M =\r\n  &Pressure_Analog_PWM_M_;\r\n\r\n/* Model step function */\r\nvoid Pressure_Analog_PWM_step(void)\r\n{\r\n  /* S-Function (adc_s32k_start): '<Root>/ADC_Start' */\r\n  {\r\n    adc_chan_config_t adc0_chan_cfg = {\r\n      .interruptEnable = false,\r\n      .channel = ADC_INPUTCHAN_EXT10\r\n    };\r\n\r\n    /* Initialize channel configuration of ADC0. */\r\n    ADC_DRV_ConfigChan(0, 0, &adc0_chan_cfg);\r\n    uint16_t result;\r\n\r\n    /* Get conversion result of ADC0 */\r\n    ADC_DRV_WaitConvDone(0);\r\n    ADC_DRV_GetChanResult(0, 0, &result);\r\n    Pressure_Analog_PWM_B.ADC_Start = result;\r\n  }\r\n\r\n  /* DataStoreWrite: '<Root>/Data Store Write' */\r\n  analog_read = Pressure_Analog_PWM_B.ADC_Start;\r\n\r\n  /* Gain: '<Root>/Gain' */\r\n  Pressure_Analog_PWM_B.Gain = 0.000244140625F * (real32_T)\r\n    Pressure_Analog_PWM_B.ADC_Start;\r\n\r\n  /* S-Function (ftm_s32k_pwm_config): '<Root>/FTM_PWM_Config' */\r\n  {\r\n    uint16_t dutyA = FTM_MAX_DUTY_CYCLE * Pressure_Analog_PWM_B.Gain;\r\n    FTM_DRV_UpdatePwmChannel(FTM_PWM0, 0U, FTM_PWM_UPDATE_IN_DUTY_CYCLE, dutyA,\r\n      0, true);\r\n  }\r\n}\r\n\r\n/* Model initialize function */\r\nvoid Pressure_Analog_PWM_initialize(void)\r\n{\r\n  /* Start for S-Function (ftm_s32k_pwm_config): '<Root>/FTM_PWM_Config' */\r\n\r\n  /* Enable clock for PORTD */\r\n  PCC_SetClockMode (PCC, PCC_PORTD_CLOCK, true);\r\n\r\n  /* Pin is configured for FTM function */\r\n  PINS_SetMuxModeSel (PORTD, 15, PORT_MUX_ALT2);\r\n\r\n  /* Set FTM_0 clock source */\r\n  PCC_SetPeripheralClockControl (PCC, FTM0_CLK, true, CLK_SRC_SPLL, 0, 0);\r\n\r\n  /* Enable clock for FTM_0 */\r\n  PCC_SetClockMode (PCC, FTM0_CLK, true);\r\n\r\n  /* PWM0 initialization */\r\n  FTM_DRV_Init (FTM_PWM0, &flexTimer_pwm0_InitConfig, &ftmStateStruct0);\r\n  FTM_DRV_InitPwm (FTM_PWM0, &flexTimer_pwm0_PwmConfig);\r\n  FTM_DRV_SetChnTriggerCmd(FTM0, 1, false);\r\n\r\n  /* Start for S-Function (adc_s32k_config): '<Root>/ADC_Config' */\r\n  {\r\n    const adc_converter_config_t adc0_cfg = {\r\n      .clockDivide = ADC_CLK_DIVIDE_1,\r\n      .sampleTime = 1.0,\r\n      .resolution = ADC_RESOLUTION_12BIT,\r\n      .inputClock = ADC_CLK_ALT_1,\r\n      .trigger = ADC_TRIGGER_SOFTWARE,\r\n      .pretriggerSel = ADC_PRETRIGGER_SEL_PDB,\r\n      .triggerSel = ADC_TRIGGER_SEL_TRGMUX,\r\n      .dmaEnable = false,\r\n      .voltageRef = ADC_VOLTAGEREF_VREF,\r\n      .continuousConvEnable = false,\r\n      .supplyMonitoringEnable = false\r\n    };\r\n\r\n    const adc_compare_config_t adc0_cmp_cfg = {\r\n      .compareEnable = false,\r\n      .compareGreaterThanEnable = false,\r\n      .compareRangeFuncEnable = false,\r\n      .compVal1 = 0,\r\n      .compVal2 = 0\r\n    };\r\n\r\n    const adc_average_config_t adc0_avrg_cfg = {\r\n      .hwAvgEnable = false,\r\n      .hwAverage = ADC_AVERAGE_4\r\n    };\r\n\r\n    /* Enable ADC0 clock */\r\n    PCC_SetClockMode(PCC, PCC_ADC0_CLOCK, false);\r\n\r\n    /* Set ADC0 clock source */\r\n    PCC_SetPeripheralClockControl(PCC, PCC_ADC0_CLOCK, true, CLK_SRC_SPLL, 0, 0);\r\n\r\n    /* Enable ADC0 clock */\r\n    PCC_SetClockMode(PCC, PCC_ADC0_CLOCK, true);\r\n    ADC_DRV_Reset(0);\r\n\r\n    /* Configure ADC0 */\r\n    ADC_DRV_ConfigConverter(0, &adc0_cfg);\r\n    ADC_DRV_SetSwPretrigger(0,ADC_SW_PRETRIGGER_DISABLED);\r\n    ADC_DRV_ConfigHwCompare(0, &adc0_cmp_cfg);\r\n    ADC_DRV_ConfigHwAverage(0, &adc0_avrg_cfg);\r\n\r\n    /* Do calibration before initialize the ADC0. */\r\n    ADC_DRV_AutoCalibration(0);\r\n  }\r\n\r\n  /* Start for S-Function (fm_s32k_config): '<Root>/FreeMaster_Config' */\r\n\r\n  /* Initialize FreeMaster. */\r\n  freemaster_interface_init();\r\n  FMSTR_Init();\r\n}\r\n\r\n/* Model terminate function */\r\nvoid Pressure_Analog_PWM_terminate(void)\r\n{\r\n  /* (no terminate code required) */\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"Pressure_Analog_PWM.h","type":"header","group":"model","path":"C:\\Users\\kamil\\OneDrive\\Documents\\GitHub\\NXP_Tests_Scaleo\\Pressure_Analog_PWM_mbd_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: Pressure_Analog_PWM.h\r\n *\r\n * Code generated for Simulink model 'Pressure_Analog_PWM'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Wed Mar 22 12:29:08 2023\r\n *\r\n * Target selection: mbd_s32k.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_Pressure_Analog_PWM_h_\r\n#define RTW_HEADER_Pressure_Analog_PWM_h_\r\n#ifndef Pressure_Analog_PWM_COMMON_INCLUDES_\r\n#define Pressure_Analog_PWM_COMMON_INCLUDES_\r\n#include <string.h>\r\n#include \"rtwtypes.h\"\r\n#include \"adc_driver.h\"\r\n#include \"ftm_pwm_driver.h\"\r\n#include \"clock_manager.h\"\r\n#include \"pcc_hw_access.h\"\r\n#include \"pins_port_hw_access.h\"\r\n#include \"ftm_hw_access.h\"\r\n#include \"ftm0_pwm_params.h\"\r\n#include \"device_registers.h\"\r\n#include \"freemaster.h\"\r\n#include \"freemaster_interface_init.h\"\r\n#endif                                /* Pressure_Analog_PWM_COMMON_INCLUDES_ */\r\n\r\n#include <stddef.h>\r\n#include \"Pressure_Analog_PWM_types.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  uint32_T ADC_Start;                  /* '<Root>/ADC_Start' */\r\n  real32_T Gain;                       /* '<Root>/Gain' */\r\n} B_Pressure_Analog_PWM_T;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_Pressure_Analog_PWM_T {\r\n  const char_T * volatile errorStatus;\r\n};\r\n\r\n/* Block signals (default storage) */\r\nextern B_Pressure_Analog_PWM_T Pressure_Analog_PWM_B;\r\n\r\n/*\r\n * Exported States\r\n *\r\n * Note: Exported states are block states with an exported global\r\n * storage class designation.  Code generation will declare the memory for these\r\n * states and exports their symbols.\r\n *\r\n */\r\nextern uint32_T analog_read;           /* '<Root>/Data Store Memory' */\r\n\r\n/* Model entry point functions */\r\nextern void Pressure_Analog_PWM_initialize(void);\r\nextern void Pressure_Analog_PWM_step(void);\r\nextern void Pressure_Analog_PWM_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_Pressure_Analog_PWM_T *const Pressure_Analog_PWM_M;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'Pressure_Analog_PWM'\r\n */\r\n#endif                                 /* RTW_HEADER_Pressure_Analog_PWM_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"Pressure_Analog_PWM_private.h","type":"header","group":"model","path":"C:\\Users\\kamil\\OneDrive\\Documents\\GitHub\\NXP_Tests_Scaleo\\Pressure_Analog_PWM_mbd_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: Pressure_Analog_PWM_private.h\r\n *\r\n * Code generated for Simulink model 'Pressure_Analog_PWM'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Wed Mar 22 12:29:08 2023\r\n *\r\n * Target selection: mbd_s32k.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_Pressure_Analog_PWM_private_h_\r\n#define RTW_HEADER_Pressure_Analog_PWM_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"Pressure_Analog_PWM_types.h\"\r\n#include \"Pressure_Analog_PWM.h\"\r\n#if defined(__MWERKS__)\r\n\r\ndouble fmod (double x, double y);\r\ndouble fabs (double);\r\n\r\n#endif\r\n#endif                           /* RTW_HEADER_Pressure_Analog_PWM_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"Pressure_Analog_PWM_types.h","type":"header","group":"model","path":"C:\\Users\\kamil\\OneDrive\\Documents\\GitHub\\NXP_Tests_Scaleo\\Pressure_Analog_PWM_mbd_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: Pressure_Analog_PWM_types.h\r\n *\r\n * Code generated for Simulink model 'Pressure_Analog_PWM'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Wed Mar 22 12:29:08 2023\r\n *\r\n * Target selection: mbd_s32k.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_Pressure_Analog_PWM_types_h_\r\n#define RTW_HEADER_Pressure_Analog_PWM_types_h_\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_Pressure_Analog_PWM_T RT_MODEL_Pressure_Analog_PWM_T;\r\n\r\n#endif                             /* RTW_HEADER_Pressure_Analog_PWM_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\kamil\\OneDrive\\Documents\\GitHub\\NXP_Tests_Scaleo\\Pressure_Analog_PWM_mbd_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'Pressure_Analog_PWM'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Wed Mar 22 12:29:08 2023\r\n *\r\n * Target selection: mbd_s32k.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: ARM Compatible->ARM Cortex\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32\r\n *                       native word size:  32\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T.                        *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"freemaster_cfg.h","type":"header","group":"","path":"C:\\Users\\kamil\\OneDrive\\Documents\\GitHub\\NXP_Tests_Scaleo\\Pressure_Analog_PWM_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: freemaster_cfg.h\r\n *\r\n * Code generated for Simulink model 'Pressure_Analog_PWM'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Wed Mar 22 12:29:08 2023\r\n *\r\n * Target selection: mbd_s32k.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_freemaster_cfg_h_\r\n#define RTW_HEADER_freemaster_cfg_h_\r\n\r\n/***************************************************************************/\r\n/*!\r\n *\r\n * @file   freemaster_cfg.h\r\n *\r\n * @brief  FreeMASTER Serial Communication Driver configuration file\r\n *\r\n *******************************************************************************/\r\n\r\n/******************************************************************************\r\n * Select interrupt or poll-driven serial communication\r\n ******************************************************************************/\r\n#define FMSTR_LONG_INTR                0                         /* complete message processing in interrupt */\r\n#define FMSTR_SHORT_INTR               0                         /* SCI FIFO-queuing done in interrupt */\r\n#define FMSTR_POLL_DRIVEN              1                         /* no interrupt needed, polling only */\r\n\r\n/*****************************************************************************\r\n * Select communication interface (SCI, CAN, USB CDC or Packet Driven BDM)\r\n ******************************************************************************/\r\n#define FMSTR_DISABLE                  0                         /* To disable all FreeMASTER functionalities */\r\n#define FMSTR_USE_SCI                  1                         /* To select SCI communication interface */\r\n#define FMSTR_SCI_BASE                 0x4006B000\r\n#define FMSTR_USE_MSCAN                0\r\n#define FMSTR_USE_FLEXCAN              0                         /* To select FlexCAN communication interface */\r\n#define FMSTR_USE_FLEXCAN32            0\r\n#define FMSTR_CAN_BASE                 0x40024000\r\n#define FMSTR_USE_SFIO                 0                         /* SFIO Toolbox has been used */\r\n#define FMSTR_USE_USB_CDC              0                         /* To select USB CDC communication interface */\r\n#define FMSTR_USE_PDBDM                0                         /* To select Packet Driven BDM communication interface (optional) */\r\n\r\n/* select RX and TX FlexCAN Message buffers */\r\n#define FMSTR_FLEXCAN_TXMB             0\r\n#define FMSTR_FLEXCAN_RXMB             1\r\n\r\n/******************************************************************************\r\n * Input/output communication buffer size\r\n ******************************************************************************/\r\n#define FMSTR_COMM_BUFFER_SIZE         0                         /* set to 0 for \"automatic\" */\r\n\r\n/******************************************************************************\r\n * Receive FIFO queue size (use with FMSTR_SHORT_INTR only)\r\n ******************************************************************************/\r\n#define FMSTR_COMM_RQUEUE_SIZE         0                         /* set to 0 for \"default\" */\r\n\r\n/*****************************************************************************\r\n * Support for Application Commands\r\n ******************************************************************************/\r\n#define FMSTR_USE_APPCMD               0                         /* enable/disable App.Commands support */\r\n#define FMSTR_APPCMD_BUFF_SIZE         0                         /* App.Command data buffer size */\r\n#define FMSTR_MAX_APPCMD_CALLS         1                         /* how many app.cmd callbacks? (0=disable) */\r\n\r\n/*****************************************************************************\r\n * Oscilloscope support\r\n ******************************************************************************/\r\n#define FMSTR_USE_SCOPE                1                         /* enable/disable scope support */\r\n#define FMSTR_MAX_SCOPE_VARS           8                         /* max. number of scope variables (2..8) */\r\n\r\n/*****************************************************************************\r\n * Recorder support\r\n ******************************************************************************/\r\n#define FMSTR_USE_RECORDER             1                         /* enable/disable recorder support */\r\n#define FMSTR_MAX_REC_VARS             8                         /* max. number of recorder variables (2..8) */\r\n#define FMSTR_REC_OWNBUFF              0                         /* use user-allocated rec. buffer (1=yes) */\r\n\r\n/* built-in recorder buffer (use when FMSTR_REC_OWNBUFF is 0) */\r\n#define FMSTR_REC_BUFF_SIZE            1024                      /* built-in buffer size */\r\n\r\n/* recorder time base, specifies how often the recorder is called in the user app. */\r\n#define FMSTR_REC_TIMEBASE             FMSTR_REC_BASE_SECONDS(0) /* 0 = \"unknown\" */\r\n\r\n/*****************************************************************************\r\n * Target-side address translation (TSA)\r\n ******************************************************************************/\r\n#define FMSTR_USE_TSA                  0                         /* enable TSA functionality */\r\n#define FMSTR_USE_TSA_SAFETY           0                         /* enable access to TSA variables only */\r\n#define FMSTR_USE_TSA_INROM            0                         /* TSA tables declared as const (put to ROM) */\r\n\r\n/*****************************************************************************\r\n * Enable/Disable read/write memory commands\r\n ******************************************************************************/\r\n#define FMSTR_USE_READMEM              1                         /* enable read memory commands */\r\n#define FMSTR_USE_WRITEMEM             1                         /* enable write memory commands */\r\n#define FMSTR_USE_WRITEMEMMASK         1                         /* enable write memory bits commands */\r\n\r\n/*****************************************************************************\r\n * Enable/Disable read/write variable commands (a bit faster than Read Mem)\r\n ******************************************************************************/\r\n#define FMSTR_USE_READVAR              1                         /* enable read variable fast commands */\r\n#define FMSTR_USE_WRITEVAR             1                         /* enable write variable fast commands */\r\n#define FMSTR_USE_WRITEVARMASK         1                         /* enable write variable bits fast commands */\r\n#endif                                 /* RTW_HEADER_freemaster_cfg_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"freemaster_interface_init.c","type":"source","group":"","path":"C:\\Users\\kamil\\OneDrive\\Documents\\GitHub\\NXP_Tests_Scaleo\\Pressure_Analog_PWM_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: freemaster_interface_init.c\r\n *\r\n * Code generated for Simulink model 'Pressure_Analog_PWM'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Wed Mar 22 12:29:08 2023\r\n *\r\n * Target selection: mbd_s32k.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"freemaster.h\"\r\n#include \"freemaster_interface_init.h\"\r\n#include \"device_registers.h\"\r\n#include \"interrupt_manager.h\"\r\n#include \"lpuart_driver.h\"\r\n#include \"lpuart_hw_access.h\"\r\n#include \"pcc_hw_access.h\"\r\n#include \"pins_port_hw_access.h\"\r\n#include \"clock_manager.h\"\r\n\r\n/* FreeMaster UART init function */\r\nvoid freemaster_interface_init(void)\r\n{\r\n  lpuart_state_t lpuartState;\r\n  lpuart_user_config_t lpuartConfig;\r\n\r\n  /* RX pin settings */\r\n  PCC_SetClockMode(PCC, PORTC_CLK, true);\r\n  PINS_SetMuxModeSel(PORTC, 6, PORT_MUX_ALT2);\r\n\r\n  /* TX pin settings */\r\n  PCC_SetClockMode(PCC, PORTC_CLK, true);\r\n  PINS_SetMuxModeSel(PORTC, 7, PORT_MUX_ALT2);\r\n\r\n  /* Set LPUART clock source */\r\n  PCC_SetPeripheralClockControl(PCC, LPUART1_CLK, true, CLK_SRC_FIRC_DIV2, 0, 0);\r\n  lpuartConfig.baudRate = 115200;\r\n  lpuartConfig.bitCountPerChar = LPUART_8_BITS_PER_CHAR;\r\n  lpuartConfig.parityMode = LPUART_PARITY_DISABLED;\r\n  lpuartConfig.stopBitCount = LPUART_ONE_STOP_BIT;\r\n  LPUART_DRV_Init(1, &lpuartState, &lpuartConfig);\r\n\r\n  /* Enable the LPUART transmitter and receiver */\r\n  LPUART_SetTransmitterCmd(LPUART1, true);\r\n  LPUART_SetReceiverCmd(LPUART1, true);\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"freemaster_interface_init.h","type":"header","group":"","path":"C:\\Users\\kamil\\OneDrive\\Documents\\GitHub\\NXP_Tests_Scaleo\\Pressure_Analog_PWM_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: freemaster_interface_init.h\r\n *\r\n * Code generated for Simulink model 'Pressure_Analog_PWM'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Wed Mar 22 12:29:08 2023\r\n *\r\n * Target selection: mbd_s32k.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_freemaster_interface_init_h_\r\n#define RTW_HEADER_freemaster_interface_init_h_\r\n\r\nvoid freemaster_interface_init(void);\r\n\r\n#endif                             /* RTW_HEADER_freemaster_interface_init_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"ftm0_pwm_params.c","type":"source","group":"legacy","path":"C:\\Users\\kamil\\OneDrive\\Documents\\GitHub\\NXP_Tests_Scaleo\\Pressure_Analog_PWM_mbd_rtw","tag":"","groupDisplay":"Other files","code":"#include \"ftm0_pwm_params.h\"\r\n\r\n/* Fault configuration structure for FTM0 */\r\nftm_pwm_fault_param_t flexTimer_pwm0_FaultConfig = {\r\n  false,                               /* Output pin state on fault */\r\n  false,                               /* PWM fault interrupt state */\r\n  0U,                                  /* Fault filter value */\r\n  FTM_FAULT_CONTROL_DISABLED,          /* Fault mode */\r\n\r\n  {\r\n    {\r\n      false,                        /* Fault channel state (Enabled/Disabled) */\r\n      false,                 /* Fault channel filter state (Enabled/Disabled) */\r\n      FTM_POLARITY_HIGH,               /* Channel output state on fault */\r\n    },\r\n\r\n    {\r\n      false,                        /* Fault channel state (Enabled/Disabled) */\r\n      false,                 /* Fault channel filter state (Enabled/Disabled) */\r\n      FTM_POLARITY_HIGH,               /* Channel output state on fault */\r\n    },\r\n\r\n    {\r\n      false,                        /* Fault channel state (Enabled/Disabled) */\r\n      false,                 /* Fault channel filter state (Enabled/Disabled) */\r\n      FTM_POLARITY_HIGH,               /* Channel output state on fault */\r\n    },\r\n\r\n    {\r\n      false,                        /* Fault channel state (Enabled/Disabled) */\r\n      false,                 /* Fault channel filter state (Enabled/Disabled) */\r\n      FTM_POLARITY_HIGH,               /* Channel output state on fault */\r\n    },\r\n  }\r\n};\r\n\r\n/* Independent channels configuration structure for flexTimer_pwm0 */\r\nftm_independent_ch_param_t flexTimer_pwm0_IndependentChannelsConfig[1] = {\r\n  {\r\n    0U,                                /* hwChannelId */\r\n    FTM_POLARITY_LOW,                  /* Edge mode */\r\n    8192U,                             /* Duty cycle percent 0-0x8000 */\r\n    false,                             /* External Trigger */\r\n    FTM_LOW_STATE,                   /* The selection of the channel (n) mode */\r\n    true,                        /* Enabled/disabled the channel (n+1) output */\r\n    FTM_MAIN_DUPLICATED,\r\n                       /* Select channel (n+1) output relative to channel (n) */\r\n    true,                              /* Dead time enabled/disabled */\r\n  },\r\n};\r\n\r\n/* PWM configuration for flexTimer_pwm0 */\r\nftm_pwm_param_t flexTimer_pwm0_PwmConfig = {\r\n  1U,                                  /* Number of independent PWM channels */\r\n  0U,                                  /* Number of combined PWM channels */\r\n  FTM_MODE_EDGE_ALIGNED_PWM,           /* PWM mode */\r\n  0U,                                  /* Dead time value */\r\n  FTM_DEADTIME_DIVID_BY_1,             /* Dead time prescaler */\r\n  10000U,                              /* PWM frequency */\r\n  flexTimer_pwm0_IndependentChannelsConfig,\r\n                          /* Independent PWM channels configuration structure */\r\n  NULL,                      /* Combined PWM channels configuration structure */\r\n  &flexTimer_pwm0_FaultConfig          /* PWM fault configuration structure */\r\n};\r\n\r\n/* Global configuration of flexTimer_pwm0 */\r\nftm_user_config_t flexTimer_pwm0_InitConfig = {\r\n  {\r\n    true,                              /* Software trigger state */\r\n    false,                             /* Hardware trigger 1 state */\r\n    false,                             /* Hardware trigger 2 state */\r\n    false,                             /* Hardware trigger 3 state */\r\n    true,                              /* Max loading point state */\r\n    true,                              /* Min loading point state */\r\n    FTM_SYSTEM_CLOCK,                  /* Update mode for INVCTRL register */\r\n    FTM_SYSTEM_CLOCK,                  /* Update mode for SWOCTRL register */\r\n    FTM_SYSTEM_CLOCK,                  /* Update mode for OUTMASK register */\r\n    FTM_SYSTEM_CLOCK,                  /* Update mode for CNTIN register */\r\n    true,                              /* Automatic clear of the trigger*/\r\n    FTM_UPDATE_NOW,                    /* Synchronization point */\r\n  },\r\n  FTM_MODE_EDGE_ALIGNED_PWM,           /* Mode of operation for FTM */\r\n  FTM_CLOCK_DIVID_BY_1,                /* FTM clock prescaler */\r\n  FTM_CLOCK_SOURCE_SYSTEMCLK,          /* FTM clock source */\r\n  FTM_BDM_MODE_00,                     /* FTM debug mode */\r\n  false,                               /* Interrupt state */\r\n  false                                /* Initialization trigger */\r\n};\r\n\r\nftm_state_t ftmStateStruct0;\r\n"},{"name":"ftm0_pwm_params.h","type":"header","group":"other","path":"C:\\Users\\kamil\\OneDrive\\Documents\\GitHub\\NXP_Tests_Scaleo\\Pressure_Analog_PWM_mbd_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef FTM0_PWM_PARAMS_H\r\n#define FTM0_PWM_PARAMS_H\r\n\r\n/* MODULE flexTimer_pwm0.*/\r\n\r\n/* Include inherited beans */\r\n#include \"ftm_pwm_driver.h\"\r\n\r\n/* Device instance number */\r\n#define FTM_PWM0                       0U\r\n\r\n/*fault configuration structure for FTM0*/\r\nextern ftm_pwm_fault_param_t flexTimer_pwm0_FaultConfig;\r\n\r\n/* Independent channels configuration structure for flexTimer_pwm0 */\r\nextern ftm_independent_ch_param_t flexTimer_pwm0_IndependentChannelsConfig[1];\r\n\r\n/* PWM configuration for flexTimer_pwm0 */\r\nextern ftm_pwm_param_t flexTimer_pwm0_PwmConfig;\r\n\r\n/* Global configuration of flexTimer_pwm0 */\r\nextern ftm_user_config_t flexTimer_pwm0_InitConfig;\r\n\r\n/* Global state structure of flexTimer_pwm0 */\r\nextern ftm_state_t ftmStateStruct0;\r\n\r\n#endif\r\n"},{"name":"mbd_main.c","type":"source","group":"","path":"C:\\Users\\kamil\\OneDrive\\Documents\\GitHub\\NXP_Tests_Scaleo\\Pressure_Analog_PWM_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: mbd_main.c\r\n *\r\n * Code generated for Simulink model 'Pressure_Analog_PWM'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Wed Mar 22 12:29:08 2023\r\n *\r\n * Target selection: mbd_s32k.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n/* Model's headers */\r\n#include \"device_registers.h\"\r\n#include \"Pressure_Analog_PWM.h\"\r\n#include \"freemaster.h\"\r\n#include \"interrupt_manager.h\"\r\n#include \"clock_manager.h\"\r\n#include \"lpit_driver.h\"\r\n#include \"lpit_hw_access.h\"\r\n#include \"pcc_hw_access.h\"\r\n#include \"s32k_clock_init.h\"\r\n\r\nvoid SYSTEM_INIT_TASK(void)\r\n{\r\n  /* Initialize model */\r\n  Pressure_Analog_PWM_initialize();\r\n}\r\n\r\nvoid SYSTEM_TASK(void)\r\n{\r\n  Pressure_Analog_PWM_step();\r\n\r\n  /* Get model outputs here */\r\n}\r\n\r\nvoid LPIT0_Ch0_IRQHandler (void)\r\n{\r\n  SYSTEM_TASK();\r\n  LPIT_DRV_ClearInterruptFlagTimerChannels(0, (1 << 0));\r\n}\r\n\r\nvoid lpit0_init()\r\n{\r\n  uint32_t busClock;\r\n\r\n  /* Un-gate pit clock*/\r\n  PCC_SetPeripheralClockControl(PCC, PCC_LPIT0_CLOCK, true, CLK_SRC_SPLL, 0, 0);\r\n\r\n  /* Enable PIT module clock*/\r\n  LPIT_Enable(LPIT0, 0U);\r\n\r\n  /* Finally, update pit source clock frequency.*/\r\n  CLOCK_SYS_GetFreq(PCC_LPIT0_CLOCK, &busClock);\r\n  static const lpit_user_config_t lpitInit = {\r\n    .enableRunInDebug = false,\r\n    .enableRunInDoze = true\r\n  };\r\n\r\n  /* Initialize PIT, enable module clock, disable run in debug. */\r\n  LPIT_DRV_Init(0, &lpitInit);\r\n}\r\n\r\nvoid lpit0_init_step_timer()\r\n{\r\n  static const lpit_user_channel_config_t lpit0InitStruct = {\r\n    .timerMode = LPIT_PERIODIC_COUNTER,\r\n    .periodUnits = LPIT_PERIOD_UNITS_MICROSECONDS,\r\n    .period = 200000,\r\n    .triggerSource = LPIT_TRIGGER_SOURCE_INTERNAL,\r\n    .triggerSelect = 1U,\r\n    .enableReloadOnTrigger = false,\r\n    .enableStopOnInterrupt = false,\r\n    .enableStartOnTrigger = false,\r\n    .chainChannel = false,\r\n    .isInterruptEnabled = true\r\n  };\r\n\r\n  /* Initialize PIT timer channel. */\r\n  LPIT_DRV_InitChannel(0, 0, &lpit0InitStruct);\r\n\r\n  /* Set priority for LPIT ISR */\r\n  INT_SYS_SetPriority(LPIT0_Ch0_IRQn, 15);\r\n  INT_SYS_InstallHandler(LPIT0_Ch0_IRQn, LPIT0_Ch0_IRQHandler, (isr_t *)0);\r\n\r\n  /* Start the timer. */\r\n  LPIT_DRV_StartTimerChannels(0, LPIT0->SETTEN | (1 << 0));\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\r\n#ifdef __FPU_USED\r\n\r\n  /* FPU ENABLE */\r\n  /* Enable CP10 and CP11 coprocessors */\r\n  S32_SCB->CPACR |= (S32_SCB_CPACR_CP10_MASK | S32_SCB_CPACR_CP11_MASK);\r\n\r\n#endif\r\n\r\n  /* Disable all interrupts.*/\r\n  INT_SYS_DisableIRQGlobal();\r\n\r\n  /* Clock initialization */\r\n  Clock_Setup();\r\n\r\n  /* Initialize the processor. */\r\n  SYSTEM_INIT_TASK();\r\n\r\n  /* Initialize system timer */\r\n  lpit0_init();\r\n\r\n  /* Enable all interrupts.*/\r\n  INT_SYS_EnableIRQGlobal();           /* interrupt_manager.c */\r\n\r\n  /* Initialize step timer interrupt. */\r\n  lpit0_init_step_timer();\r\n  while (1) {\r\n    /* FreeMaster Polling */\r\n    FMSTR_Poll();\r\n  }\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"s32k_clock_init.h","type":"header","group":"other","path":"C:\\Users\\kamil\\OneDrive\\Documents\\GitHub\\NXP_Tests_Scaleo\\Pressure_Analog_PWM_mbd_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _S32K_CLOCK_INIT_H\r\n#define _S32K_CLOCK_INIT_H\r\n#include <stdint.h>\r\n#define XTAL_FREQ                      8000000UL\r\n#define CORE_CLK_FREQ                  80000000UL\r\n\r\nvoid Clock_Setup(void);\r\nvoid UpdateSystickConfig(uint32_t ticks);\r\n\r\n#endif\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":false,"showJustificationLinks":false,"showProfilingInfo":false,"showTaskSummary":false}};